## Modular Multi-ported SRAM-based Memories ##
## Ameer  M. S.  Abdelhadi and Guy  G. F.  Lemieux ##
## The University of British Columbia (UBC)  2014 ##
## { ameer.abdelhadi; guy.lemieux } @ gmail.com ##

A fully parameterized and generic Verilog implementation of the suggested modular multi-ported SRAM-based memories, together with previous approaches are provided as open source hardware. A run-in-batch flow manager to simulate and synthesize various designs with various parameters in batch using Altera's ModelSim and Quartus II is also provided.

**LICENSE:** BSD 3-Clause ("BSD New" or "BSD Simplified") license.

Please refer to the full paper for more information:

**A. M.S. Abdelhadi and G. G.F. Lemieux, "Modular Multi-ported SRAM-based Memories," ACM/SIGDA Intl Symp. on Field-Programmable. Gate Arrays (FPGA 14), Feb. 2014.**
http://www.ece.ubc.ca/~lemieux/publications/abdelhadi-fpga2014.pdf


---


## Files and directories in this package ##
  * **README           :** Read this first!
  * **LICENSE          :** BSD 3-Clause ("BSD New" or "BSD Simplified") license
  * **fpga14-paper.pdf :** ACM/SIGDA Intl Symp. on Field-Programmable. Gate Arrays (FPGA'14) paper
  * **fpga14-slides.pdf:** ACM/SIGDA Intl Symp. on Field-Programmable. Gate Arrays (FPGA'14) slides
  * **sim              :** A C-shell script: A run-in-batch simulation flow manager
  * **syn              :** A C-shell script: A run-in-batch synthesis flow manager
  * **config.vh        :** Verilog: Generated by syn script, contains design parameters
  * **utils.vh         :** Verilog: Design pre-compile utilities
  * **mrram.v          :** Verilog: Multiread-RAM using bank replication; based on generic dual-ported RAM; optional 1 or 2-stage bypass
  * **dpram.v          :** Verilog: Generic dual-ported RAM/ optional 1 or 2-stage bypass
  * **mpram\_gen.v      :** Verilog: Generic multiported-RAM; Old data will be read in case of RAW
  * **mpram\_reg.v      :** Verilog: generic register-based multiported-RAM
  * **mpram\_xor.v      :** Verilog: Multiported-RAM based on XOR implementation
  * **lvt\_reg.v        :** Verilog: Register-based binary-coded LVT (Live-Value-Table)
  * **lvt\_bin.v        :** Verilog: Binary-coded LVT (Live-Value-Table)
  * **lvt\_1ht.v        :** Verilog: Onehot-coded LVT (Live-Value-Table)
  * **mpram\_lvt\_reg.v  :** Verilog: Multiported-RAM based on register-based LVT
  * **mpram\_lvt\_bin.v  :** Verilog: Multiported-RAM based on binary-coded LVT
  * **mpram\_lvt\_1ht.v  :** Verilog: Multiported-RAM based on onehot-coded LVT
  * **mpram.v          :** Verilog: Multiported-RAM: top hierarchy
  * **mpram\_tb.v       :** Verilog: Multiported-RAM testbench
  * **mpram\_wrp.v      :** Verilog: Multiported-RAM synthesis wrapper
  * **mpram.qpf        :** Quartus II Project File
  * **mpram.qsf        :** Quartus II Settings File
  * **syn.res          :** A list of synthesis results, each run in a separate line, including: frequency, resources usage, and runtime
  * **syn.res.example  :** Example results for 628 different designs
  * **sim.res          :** A list of simulation results, each run in a separate line, including all design styles
  * **log/             :** Altera's logs and reports


---


## Multi-ported RAM module instantiation ##

All **.v &**.vh files in this package should be copied into your work directory.
Copy the following instantiation, change parameters and connectivity to fit your design.
```
   // instantiate a multiported-RAM
mpram #( .MEMD   (MEMD   ),  // positive integer: memory depth
         .DATAW  (DATAW  ),  // positive integer: data width
         .nRPORTS(nRPORTS),  // positive integer: number of reading ports
         .nWPORTS(nWPORTS),  // positive integer: number of writing ports
         .TYPE   (TYPE   ),  // text: multi-port RAM implementation type:
                             //   "AUTO"  : Choose automatically
                             //   "REG"   : Register-based
                             //   "XOR"   : XOR-based
                             //   "LVTREG": Register-based LVT
                             //   "LVTBIN": Binary-coded I-LVT-based
                             //   "LVT1HT": Onehot-coded I-LVT-based
         .BYP    (BYP    ),  // text: Bypassing type:
                             //   WAW: Allow Write-After-Write
                             //        (need to bypass feedback ram)
                             //   RAW: New data for Read-after-Write
                             //        (need to bypass output ram)
                             //   RDW: New data for Read-During-Write
         .IFILE  (""     ))  // text: initializtion file, optional
mpram_inst ( .clk  (clk  ),  // clock
             .WEnb (WEnb ),  // write enable for each writing port               
                             //   - input : [nWPORTS-1:0            ]
             .WAddr(WAddr),  // write addresses - packed from nWPORTS write ports
                             //   - input : [`log2(MEMD)*nWPORTS-1:0]
             .WData(WData),  // write data      - packed from nRPORTS read  ports
                             //   - output: [DATAW      *nWPORTS-1:0]
             .RAddr(RAddr),  // read  addresses - packed from nRPORTS read  ports
                             //   - input : [`log2(MEMD)*nRPORTS-1:0]
             .RData(RData)); // read  data      - packed from nRPORTS read  ports
                             //   - output: [DATAW      *nRPORTS-1:0]
```


---


## sim: A run-in-batch flow manager for simulation ##

### USAGE: ###

`./sim <Depth List> <Width List> <#WritePorts List> <#ReadPorts List> <#Cycles>`

  * Use a comma delimited list; no spaces; can be surrounded by brackets (), [], {}, <>
  * RAM depth, width, number of read/write ports and cycles are positive integers

### EXAMPLES: ###

  * `./sim 1024 32 3 2 1000000`
    * Simulate 1M cycles of a 1K lines RAM, 32 bits width, 3 write & 2 read ports
  * `./sim 512,1024 8,16,32 2,3,4 1,2,3,4 1000000`
    * Simulate 1M cycles of RAMs with 512 or 1024 lines, 8, 16, or 32 bits width, 2,3, or 4 write ports, 1,2,3, or 4 read ports. Total of 72 RAM combinations

The following files and directories will be created after simulation:
  * sim.res : A list of simulation results, each run in a separate line, including all design styles


---


## syn: A run-in-batch flow manager for synthesis ##

### USAGE: ###

`./syn <Architecture List> <Bypass List> <Depth List> <Width List> <#Write Ports List> <#Read Ports List>`

  * Use a comma delimited list; no spaces; can be surrounded by brackets (), [], {}, <>
  * RAM depth, width, number of read/write ports and cycles are positive integers
  * Architecture is one of: REG, XOR, LVTREG, LVTBIN, or LVT1HT
    * REG   : Register-based multi-ported RAM
    * XOR   : XOR-based multi-ported RAM
    * LVTREG: Register-based LVT multi-ported RAM
    * LVTBIN: Binary-coded I-LVT-based multi-ported RAM
    * LVT1HT: Onehot-coded I-LVT-based multi-ported RAM
  * Bypass list is one of: NON, WAW, RAW, or RDW
    * WAW: Allow Write-After-Write (need to bypass feedback RAM)
    * RAW: new data for Read-after-Write (need to bypass output RAM)
    * RDW: new data for Read-During-Write

### EXAMPLES: ###

  * `./syn XOR NON 1024 32 3 2`
    * Synthesis a XOR-based RAM with no bypassing; 1K lines RAM; 32 bits width; 3 write & 2 read ports
  * `./syn LVTBIN,LVT1HT RAW,RDW 512,1024 8,16,32 2,3,4 1,2,3,4`
    * Synthesis LVTBIN and LVT1HT RAMs with new data RAW and RDW bypassing; 512 and 1024 lines; 8,16, and 32 data width; 2,3, and 4 write ports; 1,2,3, and 4 read ports. Total of 144 RAM combinations.

The following files and directories will be created after compilation:
  * syn.res : A list of results, each run in a separate line, including: frequency, resources usage, and runtime
  * log/    : Altera's logs and reports

